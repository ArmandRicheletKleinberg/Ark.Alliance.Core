using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
using Microsoft.EntityFrameworkCore.Query;
using Microsoft.EntityFrameworkCore.Query.Internal;

// ReSharper disable UnusedType.Global
// ReSharper disable UnusedMember.Global

namespace Ark.Data.EFCore
{
    /// <summary>
    /// Extension helpers for <see cref="IQueryable{T}"/> instances.
    /// + Enables SQL and parameter inspection for debugging scenarios.
    /// - Uses internal Entity Framework Core APIs that may change across versions.
    /// Ref: <see href="https://learn.microsoft.com/ef/core/querying/how-query-works"/>
    /// </summary>
    // ReSharper disable once InconsistentNaming
    public static class IQueryableExtensions
    {
        #region Static

        /// <summary>
        /// This is used by the <see cref="WhereContainsPrimaryKeys{T}"/> method for reflection performance purpose.
        /// </summary>
        private static MethodInfo _whereContainsPrimaryKeysContainsMethod;

        #endregion Static

        #region Methods (Public)

        /// <summary>
        /// Converts a query into the SQL string generated by Entity Framework Core.
        /// + Helps troubleshoot query translations and provider behavior.
        /// - Relies on <see cref="Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.ToQueryString{TEntity}(System.Linq.IQueryable{TEntity})"/>,
        ///   which may vary between database providers.
        /// Ref: <see href="https://learn.microsoft.com/ef/core/querying/debugging"/>
        /// </summary>
        /// <typeparam name="TEntity">The type of entity to query.</typeparam>
        /// <param name="query">The query to interpret.</param>
        /// <param name="selectClauseOnly">Whether to keep only the SELECT clause and thus to drop the parameters DECLARE statements.</param>
        /// <returns>The interpreted SQL.</returns>
        public static string ToSql<TEntity>(this IQueryable<TEntity> query, bool selectClauseOnly = false) where TEntity : class
        {
            var sql = query.ToQueryString();
            if (!selectClauseOnly)
                return sql;

            return $"SELECT {sql.SubstringFrom("SELECT ")}";
        }

        /// <summary>
        /// Retrieves parameter names and values from an EF Core query.
        /// + Facilitates reproducing issues in raw SQL or profiling tools.
        /// - Requires executing internal query providers, which may change in future versions.
        /// Ref: <see href="https://learn.microsoft.com/ef/core/querying/sql"/>
        /// </summary>
        /// <typeparam name="TEntity">The type of entity to query.</typeparam>
        /// <param name="query">The query to convert.</param>
        /// <returns>
        /// Dictionary of parameter names and values. Example:
        /// <code language="json">
        /// {
        ///   "@__p_0": 1
        /// }
        /// </code>
        /// </returns>
        public static IReadOnlyDictionary<string, object> ExtractSqlParameters<TEntity>(this IQueryable<TEntity> query) where TEntity : class
        {
            using var enumerator = query.Provider.Execute<IEnumerable<TEntity>>(query.Expression).GetEnumerator();
            var relationalQueryContext = enumerator.GetPrivateFieldValue<RelationalQueryContext>("_relationalQueryContext");

            return relationalQueryContext.ParameterValues;
        }

        /// <summary>
        /// Retrieves the <see cref="DbContext"/> that generated the query.
        /// + Grants access to context configuration and tracking information.
        /// - Employs internal EF Core services and may break after updates.
        /// Ref: <see href="https://learn.microsoft.com/ef/core/dbcontext-configuration/"/>
        /// </summary>
        /// <param name="query">The query whose context is required.</param>
        /// <returns>The underlying <see cref="DbContext"/>.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Usage", "EF1001:Internal EF Core API usage.", Justification = "<Pending>")]
        public static DbContext GetDbContext(this IQueryable query)
        {
            var bindingFlags = BindingFlags.NonPublic | BindingFlags.Instance;
            var queryCompiler = typeof(EntityQueryProvider).GetField("_queryCompiler", bindingFlags).GetValue(query.Provider);
            var queryContextFactory = queryCompiler.GetType().GetField("_queryContextFactory", bindingFlags).GetValue(queryCompiler);

            var dependencies = typeof(RelationalQueryContextFactory).GetField("_dependencies", bindingFlags).GetValue(queryContextFactory);
            var queryContextDependencies = typeof(DbContext).Assembly.GetType(typeof(QueryContextDependencies).FullName);
            var stateManagerProperty = queryContextDependencies.GetProperty("StateManager", bindingFlags | BindingFlags.Public).GetValue(dependencies);
            var stateManager = (IStateManager)stateManagerProperty;

            return stateManager.Context;
        }

        /// <summary>
        /// Filters the source by matching the supplied primary key values.
        /// + Builds an expression tree that results in parameterized SQL.
        /// - Supports only single-column primary keys.
        /// Ref: <see href="https://learn.microsoft.com/ef/core/modeling/keys"/>
        /// </summary>
        /// <typeparam name="T">Entity type to filter.</typeparam>
        /// <param name="query">The queryable source to apply the filter to.</param>
        /// <param name="keyValues">Primary key values to match.</param>
        /// <returns>
        /// Queryable restricted to the given keys. Example JSON after enumeration:
        /// <code language="json">
        /// [
        ///   { "Id": 1 }
        /// ]
        /// </code>
        /// </returns>
        public static IQueryable<T> WhereContainsPrimaryKeys<T>(this IQueryable<T> query, params object[] keyValues)
            where T : class
        {
            var context = query.GetDbContext();
            var entityType = context.Model.FindEntityType(typeof(T));
            var primaryKey = entityType.FindPrimaryKey();
            if (!primaryKey.Properties.HasSingleElement())
                Result.BadPrerequisites.WithReason("Only a single primary key is supported");

            var pkProperty = primaryKey.Properties[0];
            var pkPropertyType = pkProperty.ClrType;

            // validate passed key values
            foreach (var keyValue in keyValues)
            {
                if (!pkPropertyType.IsInstanceOfType(keyValue))
                    throw new ArgumentException($"Key value '{keyValue}' is not of the right type");
            }

            // retrieve member info for primary key
            var pkMemberInfo = typeof(T).GetProperty(pkProperty.Name);
            if (pkMemberInfo == null)
                throw new ArgumentException("Type does not contain the primary key as an accessible property");

            _whereContainsPrimaryKeysContainsMethod ??= typeof(Enumerable).GetMethods()
                .First(m => m.Name == nameof(Enumerable.Contains) && m.GetParameters().Length == 2)
                .MakeGenericMethod(typeof(object));

            // build lambda expression
            var parameter = Expression.Parameter(typeof(T), "e");
            var body = Expression.Call(null, _whereContainsPrimaryKeysContainsMethod,
                Expression.Constant(keyValues),
                Expression.Convert(Expression.MakeMemberAccess(parameter, pkMemberInfo), typeof(object)));
            var predicateExpression = Expression.Lambda<Func<T, bool>>(body, parameter);

            // run query
            return query.Where(predicateExpression);
        }

        #endregion Methods (Public)
    }
}